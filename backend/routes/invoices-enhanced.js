const express = require('express');\nconst multer = require('multer');\nconst crypto = require('crypto');\nconst Tesseract = require('tesseract.js');\nconst Invoice = require('../models/Invoice');\nconst User = require('../models/User');\nconst Transaction = require('../models/Transaction');\nconst { auth } = require('../middleware/auth');\nconst { fraudDetection } = require('../utils/fraudDetection');\nconst { riskScoring } = require('../utils/riskScoring');\nconst { gstVerification } = require('../utils/gstVerification');\nconst { notificationService } = require('../services/notification');\n\nconst router = express.Router();\nconst upload = multer({ dest: 'uploads/' });\n\n// Enhanced Invoice Upload with OCR & Verification\nrouter.post('/upload', auth, upload.single('invoiceFile'), async (req, res) => {\n  try {\n    const { invoiceNumber, amount, dueDate, customerGST, customerEmail } = req.body;\n    const smeId = req.user.userId;\n    \n    // OCR Processing\n    const ocrResult = await Tesseract.recognize(req.file.path, 'eng');\n    const extractedData = parseInvoiceOCR(ocrResult.data.text);\n    \n    // Fraud Detection\n    const fraudCheck = await fraudDetection.validateInvoice({\n      invoiceNumber,\n      amount: parseFloat(amount),\n      extractedData,\n      smeId\n    });\n    \n    if (fraudCheck.isFraudulent) {\n      return res.status(400).json({ \n        error: 'Fraud detected', \n        reasons: fraudCheck.reasons \n      });\n    }\n    \n    // GST Verification\n    const gstValid = await gstVerification.verify(customerGST);\n    \n    // Find or create customer\n    let customer = await User.findOne({ email: customerEmail });\n    if (!customer) {\n      customer = await User.create({\n        email: customerEmail,\n        role: 'customer',\n        gstNumber: customerGST,\n        isVerified: gstValid\n      });\n    }\n    \n    // Risk Scoring\n    const sme = await User.findById(smeId);\n    const riskScore = await riskScoring.calculate(sme, customer, {\n      amount: parseFloat(amount),\n      dueDate: new Date(dueDate)\n    });\n    \n    // Create Invoice\n    const invoice = await Invoice.create({\n      invoiceNumber,\n      amount: parseFloat(amount),\n      dueDate: new Date(dueDate),\n      smeId,\n      customerId: customer._id,\n      extractedData,\n      riskScore,\n      gstVerified: gstValid,\n      status: gstValid && riskScore > 30 ? 'verified' : 'pending_review',\n      invoiceHash: crypto.createHash('sha256').update(`${invoiceNumber}-${amount}-${smeId}`).digest('hex')\n    });\n    \n    // Auto-list if low risk\n    if (riskScore > 60 && gstValid) {\n      invoice.status = 'listed';\n      invoice.listedAt = new Date();\n      await invoice.save();\n      \n      // Notify investors\n      await notificationService.notifyInvestors('new_opportunity', {\n        invoiceId: invoice._id,\n        amount: invoice.amount,\n        riskScore: invoice.riskScore,\n        expectedROI: calculateExpectedROI(invoice.amount, invoice.dueDate)\n      });\n    }\n    \n    res.status(201).json({\n      invoiceId: invoice._id,\n      status: invoice.status,\n      riskScore: invoice.riskScore,\n      message: 'Invoice uploaded successfully'\n    });\n    \n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Enhanced Marketplace with Filtering\nrouter.get('/marketplace', auth, async (req, res) => {\n  try {\n    const { riskLevel, minROI, maxAmount, sector } = req.query;\n    \n    let filter = { status: 'listed' };\n    \n    if (riskLevel) {\n      const riskRanges = {\n        low: { $lte: 40 },\n        medium: { $gte: 41, $lte: 70 },\n        high: { $gte: 71 }\n      };\n      filter.riskScore = riskRanges[riskLevel];\n    }\n    \n    if (maxAmount) {\n      filter.amount = { $lte: parseFloat(maxAmount) };\n    }\n    \n    const invoices = await Invoice.find(filter)\n      .populate('smeId', 'name businessType creditRating')\n      .populate('customerId', 'name businessType')\n      .sort({ listedAt: -1 })\n      .limit(50);\n    \n    const marketplace = invoices.map(invoice => {\n      const discountRate = calculateDiscountRate(invoice.riskScore, invoice.dueDate);\n      const discountedAmount = Math.floor(invoice.amount * (1 - discountRate));\n      const expectedROI = ((invoice.amount - discountedAmount) / discountedAmount) * 100;\n      const daysToMaturity = Math.ceil((new Date(invoice.dueDate) - new Date()) / (1000 * 60 * 60 * 24));\n      \n      return {\n        id: invoice._id,\n        invoiceNumber: invoice.invoiceNumber,\n        amount: invoice.amount,\n        discountedAmount,\n        expectedROI: expectedROI.toFixed(2),\n        riskScore: invoice.riskScore,\n        daysToMaturity,\n        sme: {\n          name: invoice.smeId.name,\n          businessType: invoice.smeId.businessType,\n          creditRating: invoice.smeId.creditRating\n        },\n        customer: {\n          name: invoice.customerId.name,\n          businessType: invoice.customerId.businessType\n        },\n        listedAt: invoice.listedAt\n      };\n    });\n    \n    res.json(marketplace);\n    \n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Enhanced Funding with Escrow\nrouter.post('/:id/fund', auth, async (req, res) => {\n  try {\n    const { amount } = req.body;\n    const invoiceId = req.params.id;\n    const investorId = req.user.userId;\n    \n    const invoice = await Invoice.findById(invoiceId);\n    if (!invoice || invoice.status !== 'listed') {\n      return res.status(400).json({ error: 'Invoice not available for funding' });\n    }\n    \n    const investor = await User.findById(investorId);\n    if (investor.walletBalance < amount) {\n      return res.status(400).json({ error: 'Insufficient wallet balance' });\n    }\n    \n    // Create escrow transaction\n    const transaction = await Transaction.create({\n      fromUserId: investorId,\n      toUserId: invoice.smeId,\n      invoiceId,\n      amount: parseFloat(amount),\n      type: 'funding',\n      status: 'escrowed',\n      expectedReturn: calculateExpectedReturn(amount, invoice.amount, invoice.dueDate)\n    });\n    \n    // Update wallet balances\n    await User.findByIdAndUpdate(investorId, {\n      $inc: { walletBalance: -amount }\n    });\n    \n    // Check if fully funded\n    const totalFunded = await Transaction.aggregate([\n      { $match: { invoiceId: invoice._id, type: 'funding', status: 'escrowed' } },\n      { $group: { _id: null, total: { $sum: '$amount' } } }\n    ]);\n    \n    if (totalFunded[0]?.total >= invoice.amount * 0.9) { // 90% funding threshold\n      invoice.status = 'funded';\n      invoice.fundedAt = new Date();\n      await invoice.save();\n      \n      // Release funds to SME\n      await releaseFundsToSME(invoice._id);\n      \n      // Notify SME\n      await notificationService.notify(invoice.smeId, 'invoice_funded', {\n        invoiceNumber: invoice.invoiceNumber,\n        amount: totalFunded[0].total\n      });\n    }\n    \n    res.json({\n      transactionId: transaction._id,\n      status: 'funded',\n      message: 'Investment successful'\n    });\n    \n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Payment Webhook (Bank/UPI callback)\nrouter.post('/webhook/payment', async (req, res) => {\n  try {\n    const { transactionId, invoiceNumber, amount, status, signature } = req.body;\n    \n    // Verify webhook signature\n    const expectedSignature = crypto\n      .createHmac('sha256', process.env.WEBHOOK_SECRET)\n      .update(JSON.stringify(req.body))\n      .digest('hex');\n    \n    if (signature !== expectedSignature) {\n      return res.status(401).json({ error: 'Invalid signature' });\n    }\n    \n    if (status === 'success') {\n      const invoice = await Invoice.findOne({ invoiceNumber });\n      if (invoice && invoice.status === 'funded') {\n        invoice.status = 'repaid';\n        invoice.repaidAt = new Date();\n        await invoice.save();\n        \n        // Distribute returns to investors\n        await distributeReturns(invoice._id);\n        \n        // Notify all stakeholders\n        await notificationService.notifyRepayment(invoice._id);\n      }\n    }\n    \n    res.json({ status: 'processed' });\n    \n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Helper Functions\nfunction parseInvoiceOCR(text) {\n  const patterns = {\n    invoiceNumber: /(?:Invoice|Bill)\\s*(?:No|Number|#):?\\s*([A-Z0-9-]+)/i,\n    amount: /(?:Total|Amount|Sum):?\\s*â‚¹?\\s*([0-9,]+(?:\\.[0-9]{2})?)/i,\n    gst: /GST(?:IN)?:?\\s*([0-9]{2}[A-Z]{5}[0-9]{4}[A-Z][0-9][A-Z][0-9])/i\n  };\n  \n  return {\n    invoiceNumber: text.match(patterns.invoiceNumber)?.[1],\n    amount: parseFloat(text.match(patterns.amount)?.[1]?.replace(/,/g, '')),\n    gstNumber: text.match(patterns.gst)?.[1]\n  };\n}\n\nfunction calculateDiscountRate(riskScore, dueDate) {\n  const baserate = 0.08; // 8% base\n  const riskPremium = (100 - riskScore) * 0.001; // Risk adjustment\n  const timePremium = Math.ceil((new Date(dueDate) - new Date()) / (1000 * 60 * 60 * 24)) * 0.0001;\n  \n  return Math.min(0.25, baserate + riskPremium + timePremium); // Max 25% discount\n}\n\nfunction calculateExpectedROI(amount, dueDate) {\n  const days = Math.ceil((new Date(dueDate) - new Date()) / (1000 * 60 * 60 * 24));\n  const annualRate = 0.15; // 15% annual\n  return (amount * annualRate * days) / 365;\n}\n\nfunction calculateExpectedReturn(investedAmount, invoiceAmount, dueDate) {\n  const roi = calculateExpectedROI(invoiceAmount, dueDate);\n  return investedAmount + (roi * (investedAmount / invoiceAmount));\n}\n\nasync function releaseFundsToSME(invoiceId) {\n  const transactions = await Transaction.find({\n    invoiceId,\n    type: 'funding',\n    status: 'escrowed'\n  });\n  \n  const totalAmount = transactions.reduce((sum, txn) => sum + txn.amount, 0);\n  const platformFee = totalAmount * 0.02; // 2% platform fee\n  const netAmount = totalAmount - platformFee;\n  \n  const invoice = await Invoice.findById(invoiceId);\n  \n  // Update SME wallet\n  await User.findByIdAndUpdate(invoice.smeId, {\n    $inc: { walletBalance: netAmount }\n  });\n  \n  // Mark transactions as completed\n  await Transaction.updateMany(\n    { invoiceId, type: 'funding', status: 'escrowed' },\n    { status: 'completed', completedAt: new Date() }\n  );\n}\n\nasync function distributeReturns(invoiceId) {\n  const transactions = await Transaction.find({\n    invoiceId,\n    type: 'funding',\n    status: 'completed'\n  });\n  \n  for (const txn of transactions) {\n    const returnAmount = txn.expectedReturn;\n    \n    // Credit investor wallet\n    await User.findByIdAndUpdate(txn.fromUserId, {\n      $inc: { walletBalance: returnAmount }\n    });\n    \n    // Create return transaction record\n    await Transaction.create({\n      fromUserId: null, // System\n      toUserId: txn.fromUserId,\n      invoiceId,\n      amount: returnAmount,\n      type: 'roi_payout',\n      status: 'completed',\n      completedAt: new Date()\n    });\n  }\n}\n\nmodule.exports = router;